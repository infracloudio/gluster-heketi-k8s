#!/bin/bash
# Copyright (c) 2016 Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.
# See the License for the specific language governing permissions and
# limitations under the License.

PROG="$(basename "${0}")"
TOPOLOGY='topology.json'
LOG_FILE=''
VERBOSE=0
CLI=''
GLUSTER=0
KUBE_TEMPLATES_DEFAULT="./kube-templates"
OCP_TEMPLATES_DEFAULT="./ocp-templates"
TEMPLATES=""
NAMESPACE=""
WAIT=300
ABORT=0
NODES=""
SKIP_PREREQ=0
LOAD=0

usage() {
  echo -e "USAGE: ${PROG} [-ghv] [-c CLI] [-t <TEMPLATES>] [-n NAMESPACE] [-w <SECONDS>] [--load]
       [-l <LOG_FILE>] [<TOPOLOGY>]\n"
}

help_exit() {
  usage
  echo "This is a utility script for deploying heketi (and optionally GlusterFS) in a
Kubernetes environment.

Arguments:
  TOPOLOGY    Path to a JSON-formatted file containing the initial topology
              information for the storage heketi will manage.
              Default is '${TOPOLOGY}'.

Options:
  -g, --deploy-gluster
              Deploy GlusterFS pods on the nodes in the topology that contain
              brick devices. If the --abort flag is also specified, this flag
              indicates that all GlusterFS pods and deployments should be
              deleted as well. Default is to not handle GlusterFS deployment
              or removal.

  -c CLI, --cli CLI
              Specify the container platform CLI (e.g. kubectl, oc) to use.
              Default behavior is to auto-detect the installed CLI.

  -t TEMPLATES, --templates_dir TEMPLATES
              Location of directory containing the heketi templates for the
              various resources. Defaults are:
                * For Kubernetes: '${KUBE_TEMPLATES_DEFAULT}'.
                * For OpenShift: '${OCP_TEMPLATES_DEFAULT}'.

  -n NAMESPACE, --namespace NAMESPACE
              The namespace to use for creating resources.
              Defaults is '${NAMESPACE}'.

  -w SECONDS, --wait SECONDS
              Wait SECONDS seconds for pods to become ready. Default is '${WAIT}'.

  --load      Resumes from the Topology load. Used in case of topology load
              failure on adding nodes or devices to heketi. Fix the issue on
              device or node, then restart with --load to skip gluster
              deployment and re-run topology load command.

  -y, --yes
              Skip the pre-requisites prompt.

  -l LOG_FILE, --log-file LOG_FILE
              Save all output to the specified file.

  --abort     Abort a deployment. WARNING: Deletes all related resources.

  -h, --help  Output this help message.

  -v, --verbose
              Verbose output
"
  exit 0
}

output() {
  opts="-e"
  if [[ "${1}" == "-n" ]]; then
    opts+="n"
    shift
  fi
  out="${1}"
  echo "$opts" "${out}"
  if [[ "x${LOG_FILE}" != "x" ]]; then
    if [[ "${out}" == "\033["K* ]]; then
      out="${out:6}"
    fi
    if [[ "${out}" == "\033["*A ]]; then
      out="---"
    fi
    echo $opts "${out}" >> "${LOG_FILE}"
  fi
}

debug() {
  if [[ ${VERBOSE} -eq 1 ]]; then
    output "${@}"
  fi
}

abort() {
  ${CLI} delete all,service,jobs,deployment,secret --selector="deploy-heketi"
  ${CLI} delete dc,svc,routes heketi
  ${CLI} delete svc/heketi-storage-endpoints
  ${CLI} delete sa heketi-service-account
  if [[ "${CLI}" == *oc ]]; then
    ${CLI} delete template deploy-heketi
    ${CLI} delete template heketi
  fi
  if [[ ${GLUSTER} -eq 1 ]]; then
    while read -r node; do
      debug "Removing label from '${node}' as a GlusterFS node."
      ${CLI} label nodes ${node} storagenode-
    done <<< "$(echo -e "${NODES}")"
    ${CLI} delete all,service,jobs,ds,secret --selector="glusterfs"
    if [[ "${CLI}" == *oc ]]; then
      ${CLI} delete template glusterfs
    fi
  fi
  exit 1
}

assign() {
  key="${1}"
  assign=`expr index ${key} '='
  `
  if [[ $assign -gt 0 ]]; then
    echo "${key:assign}"
    return 0
  elif [[ $assign -eq 0 ]] &&
       [[ "x${2}" != "x" ]]; then
    echo "${2}"
    return 2
  else
    output "Required parameter for '-${key}' not specified.\n"
    usage
    exit 1
  fi
  keypos=$keylen
}

check_pods() {
  local all_ready=false
  s=0
  debug "\nChecking status of pods matching '${1}':"
  while [[ "${all_ready}" != "true" ]]; do
    if [[ ${s} -ge ${WAIT} ]]; then
      output "Timed out waiting for pods matching '${1}'."
      abort
    fi
    sleep 2
    pods=$(${CLI} get pod --no-headers --show-all --selector="${1}" 2>&1)
    if [[ ${s} -ne 0 ]] && [[ ${VERBOSE} -eq 1 ]]; then
      podlines=$(echo "$pods" | wc -l)
      ((podlines+=1))
      debug "\033[${podlines}A"
    fi
    all_ready=true
    while read -r pod; do
      debug "\033[K${pod}"
      case ${2} in
        Completed)
        status=$(echo "${pod}" | awk '{print $3}')
        if [[ "${status}" != "Completed" ]]; then
          all_ready=false
        fi
        ;;
        *)
        status=$(echo "${pod}" | awk '{print $2}')
        if [[ "${status}" != "1/1" ]]; then
          all_ready=false
        fi
        ;;
      esac
    done <<< "$(echo -e "$pods")"
    ((s+=2))
  done
}

while [[ $# -ge 1 ]]; do
  key="${1}"

  case $key in
    -*)
    keylen=${#key}
    keypos=1
    while [[ $keypos -lt $keylen ]]; do
      case ${key:${keypos}} in
        g*|-deploy-gluster)
        GLUSTER=1
        if [[ "$key" == "--deploy-gluster" ]]; then keypos=$keylen; fi
        ;;
        n*|-namespace*)
        NAMESPACE=$(assign "${key:${keypos}}" "${2}")
        if [[ $? -eq 2 ]]; then shift; fi
        keypos=$keylen
        ;;
        c*|-cli*)
        CLI=$(assign "${key:${keypos}}" "${2}")
        if [[ $? -eq 2 ]]; then shift; fi
        keypos=$keylen
        ;;
        t*|-templates_dir*)
        TEMPLATES=$(assign "${key:${keypos}}" "${2}")
        if [[ $? -eq 2 ]]; then shift; fi
        keypos=$keylen
        ;;
        w*|-wait*)
        WAIT=$(assign "${key:${keypos}}" "${2}")
        if [[ $? -eq 2 ]]; then shift; fi
        keypos=$keylen
        ;;
        y*|-yes)
        SKIP_PREREQ=1
        if [[ "$key" == "--yes" ]]; then keypos=$keylen; fi
        ;;
        l*|-log-file*)
        LOG_FILE=$(assign "${key:${keypos}}" "${2}")
        if [[ $? -eq 2 ]]; then shift; fi
        keypos=$keylen
        ;;
        -abort)
        ABORT=1
        keypos=$keylen
        ;;
        h*|-help)
        help_exit
        ;;
        -load)
        LOAD=1
        keypos=$keylen
        ;;
        v*|-verbose)
        VERBOSE=1
        if [[ "$key" == "--verbose" ]]; then keypos=$keylen; fi
        ;;
        *)
        output "Unknown option '${key:${keypos}}'.\n"
        usage
        exit 1
        ;;
      esac
      ((keypos++))
    done
    ;;
    *)
    TOPOLOGY="${key}"
    ;;
  esac
  shift
done

if [[ ${LOAD} -eq 0 ]] && [[ ${ABORT} -eq 0 ]] && [[ ${SKIP_PREREQ} -eq 0 ]]; then
  echo "Welcome to the deployment tool for GlusterFS on Kubernetes and OpenShift.

Before getting started, this script has some requirements of the execution
environment and of the container platform that you should verify.

The client machine that will run this script must have:
 * Administrative access to an existing Kubernetes or OpenShift cluster
 * Access to a python interpreter 'python'
 * Access to the heketi client 'heketi-cli'

Each of the nodes that will host GlusterFS must also have appropriate firewall
rules for the required GlusterFS ports:
 * 2222  - sshd (if running GlusterFS in a pod)
 * 24007 - GlusterFS Daemon
 * 24008 - GlusterFS Management
 * 49152 to 49251 - Each brick for every volume on the host requires its own
   port. For every new brick, one new port will be used starting at 49152. We
   recommend a default range of 49152-49251 on each host, though you can adjust
   this to fit your needs.

In addition, for an OpenShift deployment you must:
 * Have 'cluster_admin' role on the administrative account doing the deployment
 * Add the 'default' and 'router' Service Accounts to the 'privileged' SCC
 * Add the 'heketi-service-account' Service Account to the 'privileged' SCC
 * Have a router deployed that is configured to allow apps to access services
   running in the cluster

Do you wish to proceed with deployment?
"

  read -rp "[Y]es, [N]o? [Default: Y]: " ynopt
  case $ynopt in
    N*|n*)
    exit
    ;;
  esac
fi

if [[ ! -f ${TOPOLOGY} ]]; then
  echo "Topology File not found!"
  exit 1
else
  NODES=$(python - <<END
import sys
import json
import argparse

file = open('${TOPOLOGY}', 'r')
topo = json.load(file)

for cluster in topo['clusters']:
  for node in cluster['nodes']:
    print(str(node['node']['hostnames']['manage'][0]))
END
)
fi

if [[ "x${CLI}" == "x" ]]; then
  kubectl=$(type kubectl 2>/dev/null | awk '{print $3}')
  oc=$(type oc 2>/dev/null | awk '{print $3}')
  if [[ "x${oc}" != "x" ]]; then
    CLI="${oc}"
  elif [[ "x${kubectl}" != "x" ]]; then
    CLI="${kubectl}"
  else
    output "Container platform CLI (e.g. kubectl, oc) not found."
    exit 1
  fi
fi

if [[ "${CLI}" == *oc ]]; then
  output "Using OpenShift CLI."
elif [[ "${CLI}" == *kubectl ]]; then
  output "Using Kubernetes CLI."
else
  output "Unknown CLI '${CLI}'."
  exit 1
fi

if [[ "x${TEMPLATES}" == "x" ]]; then
  if [[ "${CLI}" == *oc ]]; then
    TEMPLATES="${OCP_TEMPLATES_DEFAULT}"
  else
    TEMPLATES="${KUBE_TEMPLATES_DEFAULT}"
  fi
fi

if [[ -z "$NAMESPACE" ]]; then
  if [[ "${CLI}" == *oc ]]; then
    NAMESPACE=$(${CLI} config get-contexts | awk '/^\*/ {print $5}')
  elif [[ "${CLI}" == *kubectl ]]; then
    NAMESPACE=$(${CLI} config current-context)
  fi
  if [[ -z "$NAMESPACE" ]]; then
    NAMESPACE="default"
  fi
fi

${CLI} get namespaces ${NAMESPACE} 2>/dev/null
if [[ ${?} -eq 0 ]]; then
  output "Using namespace \"${NAMESPACE}\"."
  CLI="${CLI} -n ${NAMESPACE}"
else
  output "Namespace '${NAMESPACE}' not found."
  exit 1
fi

if [[ ${ABORT} -eq 1 ]]; then
  if [[ ${SKIP_PREREQ} -eq 0 ]]; then
    echo "Do you wish to abort the deployment?"
    read -rp "[Y]es, [N]o? [Default: N]: " abortopt
    [[ $abortopt == [Yy]* ]] || exit
  fi
  abort
fi

if [[ ${LOAD} -eq 0 ]]; then
  if [[ "${CLI}" == *oc ]]; then
    ${CLI} create -f ${TEMPLATES}/deploy-heketi-template.yaml
    ${CLI} create -f ${TEMPLATES}/heketi-service-account.yaml
    ${CLI} create -f ${TEMPLATES}/heketi-template.yaml
    if [[ $GLUSTER -eq 1 ]]; then
      ${CLI} create -f ${TEMPLATES}/glusterfs-template.yaml
    fi
    ${CLI} policy add-role-to-user edit system:serviceaccount:${NAMESPACE}:heketi-service-account
  else
    ${CLI} create -f ${TEMPLATES}/heketi-service-account.yaml
  fi
fi

if [[ $GLUSTER -eq 1 ]] && [[ ${LOAD} -eq 0 ]]; then

  while read -r node; do
    debug "Marking '${node}' as a GlusterFS node."
    ${CLI} label nodes ${node} storagenode=glusterfs
  done <<< "$(echo -e "${NODES}")"
  debug "Deploying GlusterFS pods."
  if [[ "${CLI}" == *oc ]]; then
    ${CLI} process glusterfs | ${CLI} create -f -
  else
    ${CLI} create -f ${TEMPLATES}/glusterfs-daemonset.yaml
  fi

  output -n "Waiting for GlusterFS pods to start ... "
  check_pods "glusterfs-node=pod"
  output "OK"
fi

if [[ ${LOAD} -eq 0 ]]; then
  if [[ "${CLI}" == *oc ]]; then
    ${CLI} process deploy-heketi | ${CLI} create -f -
  else
    ${CLI} create -f ${TEMPLATES}/deploy-heketi-deployment.yaml
  fi
fi

output -n "Waiting for deploy-heketi pod to start ... "
check_pods "glusterfs=heketi-pod"
output "OK"

heketi_service=""
debug -n "Determining heketi service URL ... "
while [[ "x${heketi_service}" == "x" ]]; do
  if [[ "${CLI}" == *oc ]]; then
    heketi_service=$(${CLI} describe routes/deploy-heketi | grep "Requested Host:" | awk '{print $3}')
  else
    heketi_service=$(${CLI} describe svc/deploy-heketi | grep "Endpoints:" | awk '{print $2}')
  fi
  sleep 1
done
debug "OK"

hello=$(curl http://${heketi_service}/hello 2>/dev/null)
if [[ "${hello}" != "Hello from Heketi" ]]; then
  output "Failed to communicate with deploy-heketi service."
  if [[ "${CLI}" == *oc ]]; then
    output "Please verify that a router has been properly configured."
  fi
  abort
fi

tload=$(heketi-cli -s http://${heketi_service} topology load --json=${TOPOLOGY} 2>&1)
if [[ ${?} != 0 ]]; then
  output "${tload}"
  exit 1
else
  output "${tload}"
  check=$(echo $tload | grep Unable)
  if [[ "${check}" != "" ]]; then
    output "Please Check the failed Node or Device and restart with --load"
    exit 1
  fi
fi

heketi-cli -s http://${heketi_service} setup-openshift-heketi-storage
if [[ ${?} != 0 ]]; then
  output "Failed on setup openshift heketi storage"
  exit 1
fi

if [[ ! -f heketi-storage.json ]]; then
  output "heketi-storage.json file not found"
  exit 1
fi
${CLI} create -f heketi-storage.json

check_pods "job-name=heketi-storage-copy-job" "Completed"

${CLI} delete all,service,jobs,deployment,secret --selector="deploy-heketi"

if [[ "${CLI}" == *oc ]]; then
  ${CLI} process heketi | ${CLI} create -f -
else
  ${CLI} create -f ${TEMPLATES}/heketi-deployment.yaml
fi

output -n "Waiting for heketi pod to start ... "
check_pods "glusterfs=heketi-pod"
output "OK"

heketi_service=""
debug -n "Determining heketi service URL ... "
while [[ "x${heketi_service}" == "x" ]]; do
  if [[ "${CLI}" == *oc ]]; then
    heketi_service=$(${CLI} describe routes/heketi | grep "Requested Host:" | awk '{print $3}')
  else
    heketi_service=$(${CLI} describe svc/heketi | grep "Endpoints:" | awk '{print $2}')
  fi
  sleep 1
done
debug "OK"

hello=$(curl http://${heketi_service}/hello 2>/dev/null)
if [[ "${hello}" != "Hello from Heketi" ]]; then
  output "Failed to communicate with heketi service."
  if [[ "${CLI}" == *oc ]]; then
    output "Please verify that a router has been properly configured."
  fi
  abort
else
  output "heketi is now running."
fi
